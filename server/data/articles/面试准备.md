# 面试准备

## Promise

Promise 是一种异步编程解决方案，用于处理异步操作和回调函数嵌套过多的问题。Promise 实际上是一个对象，通过该对象可以获取异步操作的结果。Promise 一般包含三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。

### 使用场景

- 处理异步操作，替代回调函数嵌套
- 处理多个异步操作，并发执行
- 处理多个异步操作中的第一个完成的场景
- 错误处理

  ```javascript
  // 实现一个超时请求处理
  function fetchWithTimeout(url, timeout = 5000) {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error('请求超时'));
      }, timeout);
      fetch(url)
        .then((response) => {
          clearTimeout(timer);
          resolve(response);
        })
        .catch((error) => {
          clearTimeout(timer);
          reject(error);
        });
    });
  }

  // Promise.all方法处理多个异步任务并发执行的场景
  const promise1 = Promise.resolve(1);
  const promise2 = new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve(2);
    }, 1000);
  });
  Promise.all([promise1, promise2]).then((values) => {
    console.log(values); // [1, 2]
  });

  // 如何使用catch方法处理Promise中的错误
  fetchWithTimeout('https://www.example.com')
    .then((response) => {
      console.log(response);
    })
    .catch((error) => {
      console.error(error);
    });
  ```

### 面试题

- 实现一个超时请求处理
- Promise 的底层实现原理和使用场景
- 如何在 then 方法中返回一个 Promise 实例
- 如何使用 Promise.all 方法处理多个异步任务并发执行的场景
- 如何使用 catch 方法处理 Promise 中的错误

## 递归

递归是指函数自己调用自己的技术。递归函数的特点是在函数体内调用了自身。

### 使用场景

- 树状结构的遍历
- 数组扁平化
- 斐波那契数列的求解

  ```javascript
  // 求和
  function sum(d) {
    if (d <= 1) {
      return 1;
    }
    return d + sum(d - 1);
  }
  sum(50);

  // 写一个数组扁平化
  function flatten(arr) {
    let result = [];
    for (let i = 0; i < arr.length; i++) {
      if (Array.isArray(arr[i])) {
        result = result.concat(flatten(arr[i]));
      } else {
        result.push(arr[i]);
      }
    }
    return result;
  }

  const arr = [1, 2, [3, 4, [5, 6]]];
  console.log(flatten(arr)); // [1, 2, 3, 4, 5, 6]
  ```

### 面试题

- 写一个数组扁平化
- 递归的原理和使用场景

## JavaScript 基础知识

JavaScript 是一种轻量级的脚本语言，用于在 Web 页面中添加交互行为。JavaScript 代码可以嵌入到 HTML 页面中，也可以作为单独的 JS 文件引用。

### 使用场景

- 表单验证
- 动态网页开发
- Web 应用程序开发
- 数据可视化

  ```javascript
  javascript;
  // JS变量提升
  console.log(a); // undefined
  var a = 1;

  // 函数的调用和执行的区别
  function foo() {
    console.log('foo');
  }
  const bar = function () {
    console.log('bar');
  };
  foo(); // 函数的调用
  bar(); // 函数的调用
  const baz = foo; // 函数的赋值
  baz(); // 函数的调用，输出"foo"

  // this的指向
  const obj = {
    a: 1,
    b: function () {
      console.log(this.a);
    },
  };
  obj.b(); // 输出1

  // 作用域和闭包
  function outer() {
    const x = 1;
    return function inner() {
      console.log(x);
    };
  }
  const fn = outer();
  fn(); // 输出1

  // 常见的数据类型（如String、Number、Boolean、Object、Array等）
  const str = 'hello';
  const num = 1;
  const bool = false;
  const obj = { name: 'Alice' };
  const arr = [1, 2, 3];
  ```

### 面试题

- JS 变量提升
- 函数的调用和执行的区别
- this 的指向
- 作用域和闭包
- 常见的数据类型（如 String、Number、Boolean、Object、Array 等）

## 事件循环机制

事件循环又称消息循环，是浏览器渲染主线程的工作方式。

在 Chrome 浏览器中，主线程会开启一个不会结束的 for 循环去消息队列中取第一个任务执行，其他线程执行完后将回调函数包装成一个任务丢到消息队列中。

根据 W3C 官方解释，每个任务有不同的类型，同类型的任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级，微队列优先级最高，必须优先调用。

### 消息队列

微队列：用户存放需要最快执行的任务，优先级【最高】

交互队列：用于存放用户操作后产生的事件回调任务，优先级【高】

延时队列：用户存放计时器到达后回调任务，优先级【中】

注意：其他线程在执行延时任务时，会等计时器计时完成后再将回调任务丢到延时队列中。

### 使用场景

- 定时器
- 异步请求和回调函数
- 用户交互事件（如点击、滚动、拖拽等）
- Web Worker

  ```javascript
  // 定时器的实现原理
  function setTimeout(fn, delay) {
    const start = Date.now();
    function tick() {
      if (Date.now() - start >= delay) {
        fn();
      } else {
        setTimeout(tick, 0);
      }
    }
    setTimeout(tick, 0);
  }

  // Event Loop的原理和流程
  console.log('start');
  setTimeout(() => {
    console.log('setTimeout1');
    Promise.resolve().then(() => {
      console.log('Promise1');
    });
  }, 0);
  Promise.resolve().then(() => {
    console.log('Promise2');
    setTimeout(() => {
      console.log('setTimeout2');
    }, 0);
  });
  console.log('end');

  // 如何避免出现死循环和阻塞线程等问题
  function wrongExample() {
    while (true) {
      // 这里会一直执行，导致页面卡死
    }
  }

  function rightExample() {
    setTimeout(function () {
      // 能够将任务放到任务队列中，不会影响页面渲染
    }, 0);
  }
  ```

### 面试题

- Event Loop 的原理和流程
- 定时器的实现原理
- 如何避免出现死循环和阻塞线程等问题

## 虚拟 DOM、Diff 算法和 useEffect

虚拟 DOM 是指将页面抽象成一个虚拟的树形结构，并通过 Diff 算法比较前后状态的差异，最终只更新差异部分，从而提高页面性能。

useEffect 是 React 中一个常用的 Hook 函数，用于处理组件的副作用（如异步请求、定时器、订阅事件等），并在组件挂载、更新和卸载时执行相应的操作。

### 使用场景

- 提高页面性能
- 处理组件的副作用
- 实现定时器、轮播图、滚动加载等功能

  ```javascript
  // useEffect的原理和使用场景
  import React, { useState, useEffect } from 'react';

  function App() {
    const [count, setCount] = useState(0);

    useEffect(() => {
      document.title = `您点击了${count}次`;
    }, [count]);

    return (
      <div>
        <p>您点击了{count}次</p>
        <button onClick={() => setCount(count + 1)}>点击</button>
      </div>
    );
  }
  ```

### 面试题

- 虚拟 DOM 的原理和 Diff 算法的实现
- Hook 函数的作用及常用的 Hook 函数
- 如何优化 React 组件性能
- useEffect 的原理和使用场景

## useCallback 和 useMemo

useCallback 用于缓存一个函数，减少不必要的重新渲染。useMemo 用于缓存计算结果，提高性能。

### 使用场景

- 子组件接收函数 props 时，使用 useCallback 缓存该函数
- 处理大量时间执行的计算函数时，使用 useMemo 缓存计算结果

### 面试题

- useCallback 和 useMemo 的作用及使用场景
- 什么情况下需要使用 useCallback 和 useMemo
- useCallback 和 useMemo 如何实现缓存功能

## 设计模式

### 设计原则

dry 原则

SOLID 原则

### 设计模式范式

#### 创建型

单例

工厂

原型

#### 结构型

适配器

外观

#### 行为性

观察者

模板

策略（Map）

职责链
